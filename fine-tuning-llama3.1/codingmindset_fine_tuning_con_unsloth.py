# -*- coding: utf-8 -*-
"""CodingMindset Fine-Tuning con Unsloth.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16HZWEUpYBgAVebzPG88J2jY4ey3Iflgq

# Fine-tuning Llama 3.1 8B LoRA con Unsloth

> S√≠gueme en RRSS para apoyar este contenido ‚ù§Ô∏è: <br>
x -> [@codingmindsetio](https://x.com/codingmindsetio) <br>
YT üé• -> [CodingMindset](https://www.youtube.com/@CodingMindsetIO?sub_confirmation=1) <br>
IG üì∏ -> [@codingmindset](https://www.instagram.com/codingmindset?igsh=ZGx5aGd4MXBwYmx5&utm_source=qr)

## Instalaci√≥n e importaci√≥n de dependencias

Para instalar Unsloth en tu propio PC, sigue las instrucciones de instalaci√≥n de la p√°gina de Github [aqu√≠](https://github.com/unslothai/unsloth?tab=readme-ov-file#-installation-instructions).
"""

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# # Instala Unsloth, Xformers (Flash Attention) y todos los dem√°s paquetes.
# !pip install "unsloth[colab-new] @ git+https://github.com/unslothai/unsloth.git"
# 
# # Tenemos que comprobar qu√© versi√≥n de Torch para Xformers (2.3 -> 0.0.27)
# from torch import __version__; from packaging.version import Version as V
# xformers = "xformers==0.0.27" if V(__version__) < V("2.4.0") else "xformers"
# !pip install --no-deps {xformers} trl peft accelerate bitsandbytes triton


"""Importamos todas las dependecias a utilizar"""

import torch
from trl import SFTTrainer
from datasets import load_dataset
from transformers import TrainingArguments, TextStreamer
from unsloth.chat_templates import get_chat_template
from unsloth import FastLanguageModel, is_bfloat16_supported

"""## Descarga del modelo

### Par√°metros

 `max_seq_length`: Al preparar el modelo para su uso, es necesario establecer un l√≠mite m√°ximo para la longitud de las secuencias, lo que afecta su capacidad de procesar informaci√≥n contextual. Aunque la versi√≥n 3.1 de Llama puede manejar contextos de hasta 128 mil tokens, en este caso optaremos por una configuraci√≥n m√°s modesta de 2,048 tokens. Esta elecci√≥n se debe a que utilizar la capacidad m√°xima requiere considerablemente m√°s recursos computacionales y de VRAM.
 <br>
 <br>
 `dtype`: se refiere al tipo de datos que se utilizar√° para representar los n√∫meros en el modelo. Es importante porque afecta la precisi√≥n de los c√°lculos, el uso de memoria y la velocidad de procesamiento.

*   **None**: Detecci√≥n autom√°tica
*   **torch.float32**: Precisi√≥n est√°ndar, compatible con la mayor√≠a de GPUs
*   **torch.float16**: Para GPUs Tesla T4, V100
*   **torch.bfloat16**: Para GPUs Ampere y m√°s recientes

`load_in_4bit`: Activa la cuantizaci√≥n de 4 bits para ahorrar memoria. Es opcional (puede ser False)
 <br>
 <br>
`model_name`: En este caso escogemos la versi√≥n pre-cuantizada de Llama de 4-bit, debido a que es mucho m√°s ligera (5.4 GB) comprado con la versi√≥n original con precisi√≥n de 16-bit (16 GB)
"""

max_seq_length = 2048
dtype = None
load_in_4bit = True

model, tokenizer = FastLanguageModel.from_pretrained(
    model_name="unsloth/Meta-Llama-3.1-8B-bnb-4bit",
    max_seq_length=max_seq_length,
    load_in_4bit=True,
    dtype=None,
)

"""## Preparaci√≥n LoRA - PEFT (Parameter Efficient Fine Tuning)

LoRA tiene tres par√°metros fundamentales:

1. `r` (Rango): Este valor determina el tama√±o de las matrices de LoRA. Normalmente, se empieza con un rango de 8, pero puede llegar hasta 256. Un rango mayor permite almacenar m√°s informaci√≥n, pero tambi√©n aumenta el coste computacional y de memoria. En este caso, hemos optado por un valor de 16.

2. `lora_alpha` (Œ±): Es un factor de escala para las actualizaciones. Alfa influye directamente en cu√°nto contribuyen los adaptadores (controla la magnitud de la contribuci√≥n de los adaptadores LoRA a la red principal) y suele establecerse como 1 o 2 veces el valor del rango. En este caso, hemos optado por un valor de 16 (1 * r).

3. `target_modules`: LoRA se puede aplicar a varios componentes del modelo, como los mecanismos de atenci√≥n (matrices Q, K, V), proyecciones de salida, bloques feed-forward y capas lineales de salida. Aunque inicialmente se centra en los mecanismos de atenci√≥n, expandir LoRA a otros componentes ha demostrado ser beneficioso. Sin embargo, adaptar m√°s m√≥dulos implica un aumento en el n√∫mero de par√°metros entrenables y en las necesidades de memoria. En este caso,  hemos decidido aplicar LoRA a todos los m√≥dulos lineales para maximizar la calidad.

Otros par√°metros:

`lora_dropout`: T√©cnica de regularizaci√≥n que desactiva aleatoriamente un porcentaje de conexiones en las matrices de adaptaci√≥n durante el entrenamiento. Su objetivo principal es prevenir el sobreajuste. Ralentiza ligeramente el entrenamiento por lo que en este caso optamos por no usarlo.

`use_rslora` (Estabilizador de rango): Introduce una modificaci√≥n en el factor de escala de los adaptadores LoRA. En lugar de usar una proporci√≥n de 1/r, emplea 1/‚àör. Este sutil pero importante cambio tiene dos efectos principales:

1. Estabiliza el proceso de aprendizaje, siendo especialmente beneficioso cuando se utilizan rangos de adaptador m√°s altos.

2. Permite mejorar el rendimiento del fine-tuning a medida que se incrementa el rango del adaptador.

En esencia, rsLoRA busca optimizar el equilibrio entre la capacidad de adaptaci√≥n y la estabilidad del entrenamiento, especialmente al trabajar con configuraciones de LoRA m√°s complejas.

`use_gradient_checkpointing`: Unsloth se encarga de gestionar el checkpointing del gradiente. Esta t√©cnica consiste en almacenar temporalmente en el disco duro las capas de embedding de entrada y salida, en lugar de mantenerlas constantemente en la memoria de la tarjeta gr√°fica. El objetivo principal de esta estrategia es optimizar el uso de la VRAM, liberando espacio para otros procesos del modelo durante el entrenamiento.
"""

model = FastLanguageModel.get_peft_model(
    model,
    r=16,
    lora_alpha=16,
    lora_dropout=0,
    target_modules=["q_proj", "k_proj", "v_proj", "up_proj", "down_proj", "o_proj", "gate_proj"],
    use_rslora=True,
    use_gradient_checkpointing="unsloth"
)

"""## Preparaci√≥n del Dataset y el Tokenizador

Preparamos el tokenizador
"""

tokenizer = get_chat_template(
    tokenizer,
    mapping={"role": "from", "content": "value", "user": "human", "assistant": "gpt"},
    chat_template="chatml",
)

"""En este caso vamos a usar el dataset `"mlabonne/FineTome-100k"`. Usa el formato ShareGPT (dataset), ideal para conversaciones multi-turno. Este formato se procesa para extraer pares de instrucci√≥n-respuesta. Luego, los datos se reformatean seg√∫n una plantilla de chat, como ChatML, que estructura la conversaci√≥n. ChatML usa tokens especiales para marcar el inicio y fin de cada mensaje."""

def apply_template(examples):
    messages = examples["conversations"]
    text = [tokenizer.apply_chat_template(message, tokenize=False, add_generation_prompt=False) for message in messages]
    return {"text": text}

dataset = load_dataset("mlabonne/FineTome-100k", split="train")
dataset = dataset.map(apply_template, batched=True)

"""## Entrenamiento

Los hiperpar√°metros clave en el entrenamiento de modelos incluyen:

1. **`packing` (Empaquetado)**: T√©cnica para combinar m√∫ltiples muestras peque√±as en un lote, mejorando la eficiencia del procesamiento.

2. **`learning_rate` (Tasa de aprendizaje)**: Controla la intensidad de las actualizaciones de los par√°metros. Debe equilibrarse para evitar un aprendizaje lento o inestable. Usaremos 0.0003 (3e-4)

3. **`lr_scheduler_type` (Planificador de tasa de aprendizaje)**: Ajusta la tasa durante el entrenamiento, generalmente comenzando alta y disminuyendo gradualmente. En este caso nos decantamos por la opcion lineal, una de las opciones m√°s comunes.

4. **`per_device_train_batch_size` (Tama√±o del lote)**: Determina cu√°ntas muestras se procesan antes de actualizar los pesos. Lotes m√°s grandes pueden mejorar la estabilidad y velocidad, pero requieren m√°s memoria. El tama√±o del lote ser√° 8.

5. **`gradient_accumulation_steps` (Acumulador de gradientes)**: Es una t√©cnica que permite simular un tama√±o de lote m√°s grande sin aumentar el uso de memoria. Funciona acumulando gradientes durante varias pasadas hacia adelante y hacia atr√°s antes de realizar una actualizaci√≥n de los pesos del modelo. Para esta ocasi√≥n, con 2 ser√° suficiente.

6. **`num_train_epochs` (N√∫mero de √©pocas)**: Cantidad de veces que el modelo recorre todo el conjunto de datos. M√°s √©pocas pueden mejorar el rendimiento, pero tambi√©n pueden causar sobreajuste. Para ejemplificar usar√© 1 step, una vuelta completa a todo el set de entramiento.

7. **`optim` (Optimizador)**: Algoritmo para ajustar los par√°metros del modelo. Se recomienda AdamW de 8 bits por su eficiencia en uso de memoria.

8. **`weight_decay` (Decaimiento de pesos)**: T√©cnica de regularizaci√≥n que penaliza pesos grandes para prevenir el sobreajuste.

9. **`warmup_steps`** (Pasos de calentamiento): Periodo inicial donde la tasa de aprendizaje aumenta gradualmente, ayudando a estabilizar el entrenamiento.


Cada uno de estos hiperpar√°metros juega un papel crucial en el rendimiento y la eficiencia del entrenamiento, y su ajuste adecuado es fundamental para obtener los mejores resultados.

Otros par√°metros:
- `fp16`: Habilita el entrenamiento en precisi√≥n mixta de 16 bits (si bfloat16 no es compatible).

- `bf16`: Habilita el entrenamiento en bfloat16 (si es compatible).

- `seed`: Semilla para la generaci√≥n de n√∫meros aleatorios (puede ser cualquier n√∫mero).
"""

trainer=SFTTrainer(
    model=model,
    tokenizer=tokenizer,
    train_dataset=dataset,
    dataset_text_field="text",
    max_seq_length=max_seq_length,
    dataset_num_proc=2,
    packing=True,
    args=TrainingArguments(
        learning_rate=3e-4,
        lr_scheduler_type="linear",
        per_device_train_batch_size=8,
        gradient_accumulation_steps=2,
        num_train_epochs=1,
        fp16=not is_bfloat16_supported(),
        bf16=is_bfloat16_supported(),
        logging_steps=1,
        optim="adamw_8bit",
        weight_decay=0.01,
        warmup_steps=10,
        output_dir="output",
        seed=0,
    ),
)

"""Ejecutamos el entranamiento"""

trainer_stats = trainer.train()

"""## Inferencia

`FastLanguageModel.for_inference()` nos proporciona de manera nativa una inferencia el doble de r√°pida
"""

model = FastLanguageModel.for_inference(model)

"""Finalmente. realizamos la inferencia:"""

messages = [
    {"from": "human", "value": "Which number is larger: 9.9 or 9.11"},
]

inputs = tokenizer.apply_chat_template(
    messages,
    tokenize=True,
    add_generation_prompt=True,
    return_tensors="pt",
).to("cuda")

text_streamer = TextStreamer(tokenizer)

outputs = model.generate(input_ids=inputs, streamer=text_streamer, max_new_tokens=128, use_cache=True)

"""## Guardado del modelo

Ahora es el momento de guardar nuestro modelo entrenado. Es importante recordar que, debido a la naturaleza de LoRA y QLoRA, lo que realmente hemos entrenado no es el modelo completo, sino un conjunto de adaptadores.

Unsloth nos ofrece tres m√©todos para guardar nuestro trabajo:

1. `lora`: Este m√©todo guarda √∫nicamente los adaptadores, sin el modelo base.

2. `merged_16bit`: Combina los adaptadores con el modelo base y los guarda en precisi√≥n de 16 bits.

3. `merged_4bit`: Similar al anterior, pero guarda el modelo combinado en precisi√≥n de 4 bits, lo que resulta en un archivo m√°s compacto.

La elecci√≥n del m√©todo depender√° de nuestras necesidades espec√≠ficas de almacenamiento y uso futuro del modelo. En nuestro caso escogemos la opci√≥n de 16bit para mayor precisi√≥n.
"""

# Guarda el modelo en local
model.save_pretrained_merged("lora_model", tokenizer, save_method="merged_16bit")

"""Guardamos el modelo en nuestro repositorio de HuggingFace"""

model.push_to_hub_merged("3lv27/CodingMindsetTunnedLlama-3.1-8B", tokenizer, save_method="merged_16bit", token="")

"""Unsloth ofrece una funcionalidad adicional muy √∫til: la conversi√≥n directa de tu modelo al formato GGUF. Este formato de cuantizaci√≥n, dise√±ado originalmente para llama.cpp, es ampliamente compatible con diversos motores de inferencia, como LM Studio, Ollama, etc.

Una de las ventajas del formato GGUF es que permite especificar diferentes niveles de precisi√≥n. Aprovecharemos esta caracter√≠stica para generar m√∫ltiples versiones cuantizadas del modelo. Concretamente, crearemos versiones en las siguientes precisiones: `q2_k`, `q3_k_m`, `q4_k_m`, `q5_k_m`, `q6_k` y `q8_0`.

Todas estas versiones cuantizadas se subir√°n a Hugging Face. El repositorio contendr√° todos nuestros archivos GGUF generados.

Esta approach nos permite ofrecer una gama de opciones que equilibran el tama√±o del modelo y su precisi√≥n, adapt√°ndose as√≠ a diferentes necesidades de implementaci√≥n.
"""

model.push_to_hub_gguf(
        "3lv27/CodingMindsetTunnedLlama-3.1-8B-GGUF", # Cambia hf por tu nombre de usuario / nombre del repo
        tokenizer,
        quantization_method = ["q2_k", "q3_k_m", "q4_k_m", "q5_k_m", "q6_k", "q8_0"],
        token = "", # Obt√©n tu token de hf en https://huggingface.co/settings/tokens
    )

"""## Nota importante

Si has llegado hasta aqu√≠, espero que este tutorial detallado te haya sido de gran ayuda. Si ha sido as√≠, te agradecer√≠a mucho que me ayudases apoyando el contenido para poder seguir creando estos tutoriales tan detallados, ya que llevan muchas horas de trabajo.

Apoya el contenido dej√°ndo tu like y un comentario üôèüôè‚ù§Ô∏è

Y no olvides seguirme en mis redes!

x -> [@codingmindsetio](https://x.com/codingmindsetio) <br>
YT üé• -> [CodingMindset](https://www.youtube.com/@CodingMindsetIO?sub_confirmation=1) <br>
IG üì∏ -> [@codingmindset](https://www.instagram.com/codingmindset?igsh=ZGx5aGd4MXBwYmx5&utm_source=qr)

Muchas gracias de coraz√≥n! ‚ù§Ô∏è
"""

from functools import partial

quant_methods = ["q2_k", "q3_k_m", "q4_k_m", "q5_k_m", "q6_k", "q8_0"]

def push_to_hub_gguf_with_quant(model, tokenizer, hub_path, quant):
    model.push_to_hub_gguf(hub_path, tokenizer, quant, token="")

push_model = partial(push_to_hub_gguf_with_quant, model, tokenizer, "3lv27/CodingMindsetTunnedLlama-3.1-8B-GGUF")

list(map(push_model, quant_methods))